# 운영체제 공부 

## 프로세스 (2023-02-20 ~ 2-22)
- 프로세스 메모리 배치 
  ![image](https://user-images.githubusercontent.com/37799491/220115973-ee174548-4476-49f7-a666-28126faf1719.png)
  - 텍스트 : 실행 코드
  - 데이터 : 전역 변수
  - 힙 : 프로그램 실행 중에 동적으로 할당되는 메모리
  - 스택 : 함수 호출 할때 임시데이터 저장장소(함수 매개변수, 복귀주소 및 지역 변수)
 
- 프로세스 상태
  - 프로세스는 실행되면서 그 상태가 변한다. 특정 한순간 CPU 코어에서는 오직 하나의 프로세스만이 실행이 가능하다. (문맥교환)
  - 실행, 대기, 준비, 종료 
  
- 프로세스 제어블록 (PCB)
  - 각 프로세스는 운영체제에서 PCB에 의해 표현 된다. PCB에는 특정 프로세스와 연관된 정보를 가지고 있다.
  - 구성요소 
    - 프로그램 카운터 : 프로세스가 다음에 실행할 명령의 주소를 가리킨다.
    - CPU 레지스터 : 인터럽트 발생 시 저장되어야한다.
    - CPU-스케쥴링 정보 : 이 정보는 프로세스 우선순위, 스케쥴 큐에 대한 포인터와 다른 스케쥴 매개변수를 포함한다.
    - 메모리 관리 정보 : BASE 레지스터와 한계 레지스터의 값, 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보 포함
    - Accounting 정보 : CPU 사용 시간과 경과된 실시간, 시가제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함
    - 프로세스 상태 : 실행, 준비, 대기, 종료 
    - 프로세스 번호 
    - 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 
    
- 프로세스 스케쥴링 
  - 다중 프로그래밍의 목적은 CPU 이용을 최대화하기 위하여 항상 어떤 프로세스가 실행 되도록 하는데 있다.
  - 프로세스 스케쥴러 : 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다.
  - 스케줄링 큐 : 프로세스가 OS에 의해 admit 되면 Ready queue에 들어가서 준비 상태로 바뀌어 CPU 코어에서 dispatch 될때까지 기다린다. 
    queue는 일반적으로 연결리스트로 저장된다. 준비 queue header에는 리스트의 첫 번째 PCB에 대한 포인터가 저장되고 각 PCB 에는 준비 queue의 다음 PCB를 가리키는 포인터 필드가 포함 
    다양한 큐가 존재한다. I/O 완료 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 I/O wait queue에 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 wait queue
    
- CPU 스케쥴링 
  - CPU 스케쥴러의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당하는것이다.
  - 문맥교환 : 커널은 과거 프로세스의 명령을 PCB에 저장하고, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구한다.
    문맥 교환이 진행될 동안 시스템이 아무런 유용한 일을 못 하기 때문에 문맥 교환 시간은 순수한 오버헤드 이다.

- 프로세스 생성
  - 실행되는 동안 프로세스는 여러 개의 새로운 프로세스들을 생성 할 수 있다. 앞에서 언급 한 것과 같이 생성하는 프로세스를
    부모 프로세스라고 부르고, 새로운 프로세스는 자식 프로세스라고 부른다. 이 새로운 프로세스들은 각각 다시 다른 프로세스들을 생성할 수 있으며,
    그 결과 프로세스의 트리를 형성한다.
  - Unix 시스템에서는 언제나 pid가 1인 systemd 프로세스가 모든 프로세스의 부모 역할을 하고 시스템이 부트될때 생성되는 첫 번째 사용자 프로스세 이다.
  - Unix 는 fork() 를 사용하여 프로세스를 생성하며, fork() 시스템 콜 이후 두 프로세스 중 한 프로세스가 exec() 시스템 콜을 사용하여 자신의 메모리 공간을 
    새로운 프로그램으로 교체한다.

- 프로세스 간 통신(IPC)
  - 공유 메모리 : 특정 영역에 데이터를 읽고 쓰고 함으로써 정보를 교환 가능하며, 공유 메모리 영역을 구축할 때만 시스템이 콜이 필요하다. 
    - POSIX 공유메모리 
        - 메모리-사상 파이을 사용하여 구현
        - shm_open()을 사용해서 공유메모리 객체 구현 
        - ftruncate() 메모리 크기 설정 
        - mmap() 사용하여 메모리 - 사상 파일을 구축 
        - sprintf() 공유 메모리에 기록 
        - shm_unlink() 공유 메모리 제거 
  - 메시지 전달 : 통상 시스템 콜을 사용하여 구현되므로 커널 간섭 등의 부가적인 시간 소비 작업이 필요하다.
  
  
